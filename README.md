# 项目简介
本项目基于SpringBoot开发了高并发的限时抢购秒杀系统，除了实现基本的登录、查看商品列表、下单秒杀等功能外，还针对可能出现的高并发问题进行解决，解决方式包括缓存、限流等。此外，还通过Jmeter工具对项目进行压力测试。
## 开发技术
前端技术|后端技术|中间件技术
-|-|-
Bootstrap+jQuery+Thymeleaf|SpringBoot+Mybatis+MySQL|Druid+Redis+RabbitMQ+Guava
## 秒杀优化方向
+ 尽可能将请求都拦截到系统的上游：在高并发的情况下，大量的请求打到后端数据库，数据读写锁的冲突严重，读取数据速度低，容易造成数据库宕机。可以通过限流等措施来最大化减小对数据库的访问。
+ 尽可能利用缓存：秒杀商品读多写少，考虑到数据库的读写性能较慢，可通过利用缓存来提升并发量，并缓解数据库的高负荷。
## 具体实现
### 两次MD5加密
将用户输入的密码和固定的salt通过MD5加密生成第一次加密后的密码，之后再将加密后的密码和随机生成的salt通过MD5进行第二次加密，最终将第二次加密后的密码和固定的salt保存在数据库中。
+ 防止用户的密码在网络中明文传输
+ 防止通过数据库储存密码反推出用户真正密码
### Session共享
验证用户账号密码正确后，通过UUID生成唯一id作为token，以token为key，用户信息为value模拟session储存到redis中，同时将token存储到cookie，保存登录状态
+ 在分布式集群情况下，服务器间同步可能因为延迟导致session不一致，通过redis吧session数据集中存储，解决session不一致的问题
### JSR303自定义参数验证
通过JSR303自定义校验器，实现对用户账号、密码的验证，使验证逻辑从业务代码中脱离处理，减少代码量。
### 全局异常统一处理
拦截所有异常，通过包装类统一将展示异常。
### 页面级缓存+对象级缓存
+ 页面级缓存：将手动渲染的html页面数据缓存到redis中，先尝试从缓存中读取页面，获取不到再手动渲染。
+ 对象级缓存：对用户信息、商品信息、订单信息和token等数据进行缓存，利用缓存来减少对数据库的访问。
### 页面静态化、前后端分离
对商品详情页和订单详情页进行页面静态化处理，页面中的动态数据通过调用接口从服务端获得，实现前后端分离，镜头页面无需连接数据库，因此打开速度会更快。
### 本地标记+redis预处理+RabbitMQ异步下单+客户端轮询
通过三层缓存保护，1.本地标记 2.redis预处理 3,消息队列异步下单，最后才访问数据库，这样做最大力度减小对数据库的访问。
具体细节：
+ 秒杀阶段通过本地HashMap标记用户秒杀过的商品，若标记过直接返回重复秒杀，未被标记才查询redis
+ 抢购开始时，通过实现InitializingBean，将商品和库存数据预加载到redis中，所有的抢购操作在redis中处理，预减库存减少数据库访问
+ 通过RabbitMQ使用异步队列处理下单
+ client端通过js轮询，查询获取状态
### 如何解决超卖
描述：当商品库存不足时，多个用户并发购买，可能导致库存变为负数，并创建超卖的订单。
措施：
+ 数据库层面，sql语句增加判断条件，当库存大于0才进行更新
+ 通过@Transaction来实现回滚
+ 对用户id和商品id建立唯一索引，通过这种约束来避免同一个用户秒杀两件相同的商品
### 使用数学公式验证码
点击秒杀前，需要输入数学公式验证码，验证正确才能进行秒杀
好处：
+ 防止恶意机器人和爬虫
+ 分散用户请求，缓解大流量
实现：
+ 前端通过商品id作为参数调用服务端创建验证码接口
+ 服务端通过前端传过来的商品id和用户id生成验证码，并将商品id和用户id作为key，生成的验证码作为value存入redis，同时将生成的 验证码输入图片写入imageIO让前端展示
+ 将用户输入的验证码与根据商品id+用户id从redis查询到的验证码进行对比，相同则验证成功进入秒杀，不同则验证失败。
### 秒杀接口隐藏
实现：
+ 秒杀按钮调用获取路径的接口，将随机生成的接口存入redis中，再将生成的path作为参数传入秒杀接口，接口中对path进行验证，验证成功才能进行秒杀。
### 使用RateLimiter实现限流
项目使用RateLimiter实现限流，RateLimiter是Guava提供的基于令牌桶算法的限流实现类，通过调整生成token的速率来限制用户频繁访问秒杀页面，防止超大流量冲垮系统。
## 压测效果
+ 优化前：开启1000个线程循环10次访问，QPS = 146
+ 优化后：开启1000个线程循环10吃访问，QPS = 361
